<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<style>
  .container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  .button {
    border-radius: 5px;
    background-color: #008CBA;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
  }
</style>
</head>
<body>
  <div class="container">
    <canvas id="wheel" width="1200" height="600"></canvas>
    <button id="spin-button" class="button">Start</button>
  </div>
  <!-- <script src="script.js"></script> -->
  <script>
    const urlSearchParams = new URLSearchParams(window.location.search);
    const params = Object.fromEntries(urlSearchParams.entries());
    // const condition = Number(params.condition);

    const canvas = document.getElementById("wheel");

    const wheelRadius = 75;
    const wheelSpacing = 40;
    const wheelCount = 6;
    const wheelRows = 2; 

    canvas.height = (2 * wheelRows + 1) * (wheelRadius + wheelSpacing); 
    canvas.width = (2 * (wheelCount / wheelRows) + 1) * (wheelRadius + wheelSpacing);

    const context = canvas.getContext("2d");

    const degToRad = (deg) => deg * Math.PI / 180;

    const wheelProb = .11;
    const winFraming = true;
    targetColor = "black";
    backgroundColor = "silver";

    const targetStart = -1 * wheelProb * Math.PI + Math.PI/2;
    const targetEnd = 1 * wheelProb * Math.PI + Math.PI/2;
    const grayZone = { start: targetEnd, end: targetStart + 2 * Math.PI, color: backgroundColor };
    const targetZone = { start: targetStart, end: targetEnd, color: targetColor };

    let rotations = Array(wheelCount).fill(0);
    let isSpinning = Array(wheelCount).fill(false);
    let slowDown = Array(wheelCount).fill(false);
    let speeds = Array(wheelCount).fill(0.15);
    let slowdownPoints = Array(wheelCount).fill(0);
    for (let i = 0; i < wheelCount; i++) {
      slowdownPoints[i] = Math.random() * (2 * Math.PI);
    }
    let timeStart = Date.now();
    let slowdownDelays = Array.from(Array(wheelCount).keys());
    for (let i = 0; i < wheelCount; i++) {
      slowdownDelays[i] = 3000 * slowdownDelays[i] + 2000;
    }
    let results = Array(wheelCount).fill(null);
    let tallies = Array(wheelCount).fill(null);
    let winCount = 0;

    function drawWheel(centerX, centerY, rotation, tally) {
      [grayZone, targetZone].forEach(zone => {
        context.beginPath();
        context.arc(centerX, centerY, wheelRadius, zone.start + rotation, zone.end + rotation);
        context.lineTo(centerX, centerY);
        context.closePath();
        context.fillStyle = zone.color;
        context.fill();
      });

      context.beginPath();
      context.moveTo(centerX, centerY - wheelRadius + 0);
      context.lineTo(centerX - 10, centerY - wheelRadius - 10);
      context.lineTo(centerX + 10, centerY - wheelRadius - 10);
      context.closePath();
      context.fillStyle = "black";
      context.fill();

      context.strokeRect(centerX - 20, centerY - wheelRadius - 50, 40, 20);
      if (tally !== null) {
        context.font = "16px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(tally, centerX, centerY - wheelRadius - 40);
      }
    }

    function spinWheel(i) {
      if (!isSpinning[i]) {
        isSpinning[i] = true;
        slowDown[i] = false;
        results[i] = null;
      }
    }

    function stopWheel(i) {
      if (isSpinning[i]) {
        isSpinning[i] = false;
        results[i] = rotations[i] >= targetZone.start + Math.PI/2 && rotations[i] <= targetZone.end + Math.PI/2;

        if (results[i]) {
          tallies[i] = String(results.slice(0,i+1).filter(Boolean).length);
        } else {
          tallies[i] = "x";
        }

        if (i==wheelCount-1) {
          const message = JSON.stringify({
            message: JSON.stringify(tallies),
            type: "data"
          });
          window.parent.postMessage(message,"*");  
        }
      }
    }

    function slowWheel(i) {
      if (isSpinning[i]) {
        slowDown[i] = true;
      }
    }

    document.getElementById("spin-button").addEventListener("click", () => {
      let timeStart = Date.now();
      for (let i = 0; i < wheelCount; i++) {
        spinWheel(i);
      }
    });

    function gameLoop() {
      context.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < wheelCount; i++) {
        const row = Math.floor(i / (wheelCount / wheelRows));
        const column = i % (wheelCount / wheelRows);
        const centerX = (2 * column + 1) * (wheelRadius + wheelSpacing);
        const centerY = (2 * row + 1) * (wheelRadius + wheelSpacing) + wheelSpacing;
        rotations[i] %=  2 * Math.PI;
        drawWheel(centerX, centerY, rotations[i], tallies[i]);
        
        if (Date.now() > timeStart + slowdownDelays[i]) {
          slowDown[i] = true;
        }

        if (isSpinning[i]) {
          rotations[i] += speeds[i];
          if (slowDown[i]) {
            if (slowdownPoints[i] > 0) {
              slowdownPoints[i] -= speeds[i];
            } else {
              speeds[i] *= .98;
            }
          }
        }

        if (speeds[i] < .01) {

          stopWheel(i);

        }

    

      }

      
      
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
